xp = require("xp.xp")
ease = require("ease.ease")

function init(self)
	math.randomseed(os.time())
	math.random();math.random();math.random();math.random();math.random();
	-- clearing junk rng

	
	xp.verbose = true
	xp.init()
	msg.post(".", "acquire_input_focus")
	msg.post("@render:", "clear_color", { color = vmath.vector4(140/255, 127/255, 112/255, 1) } )
	self.time = 0


	
	self.xp = {}
	self.xp_clipper_node = gui.get_node("xp_clipper")
	self.xp_fg_node = gui.get_node("xp_fg")
	self.xp_clipper_position_original = gui.get_position(self.xp_clipper_node)
	self.xp_fg_position_original = gui.get_position(self.xp_fg_node)
	self.xp_clipper_position_current = gui.get_position(self.xp_clipper_node)
	self.xp_fg_position_current = gui.get_position(self.xp_fg_node)	
	self.xp_width = gui.get_size(self.xp_fg_node).x

	self.level = 1
	
	self.current_xp = 0
	self.max_xp = 20000
	self.duration = 0.75 -- seconds to finish
	self.total = math.min(self.current_xp / self.max_xp * 100, 100) -- total progress amount
	self.initial = 0 -- starting value	
	self.total_new = self.total - self.initial -- progress amount to ease toward from initial value
end

function final(self)

end

local function update_xp(self)
	if self.initial ~= 100 then
		self.time = 0
		self.current_xp = self.current_xp + math.max(math.random(4000), 1000)
		print(self.current_xp, self.max_xp)
		self.initial = self.total
		self.total = math.min(self.current_xp / self.max_xp * 100, 100) -- total progress amount
		self.total_new = self.total - self.initial
	end

	--print(self.initial, self.current_xp, self.total, self.easing)
end

local function level_up(self)

	self.level = self.level + 1
	
	self.time = 0
	self.current_xp = self.current_xp - self.max_xp
	print(self.current_xp, self.max_xp)
	self.initial = 0
	self.total = math.min(self.current_xp / self.max_xp * 100, 100) -- total progress amount
	self.total_new = self.total - self.initial
	
end

function update(self, dt)

	self.time = self.time + dt
	self.easing = ease.out_cubic(math.min(self.time, self.duration), self.duration, 0, self.total_new) + self.initial
	if self.easing > 100 then self.easing = 100 end
	if (self.easing == self.total and self.current_xp >= self.max_xp) or self.current_xp >= self.max_xp and self.easing >= 100 then
		print("level up!")
		level_up(self)
	end
	--print(easing)
	self.xp_clipper_position_current.x = self.xp_clipper_position_original.x - self.xp_width * (100 - self.easing) / 100
	self.xp_fg_position_current.x = self.xp_fg_position_original.x + self.xp_width * (100 - self.easing) / 100 
	gui.set_position(gui.get_node("xp_clipper"), self.xp_clipper_position_current)
	gui.set_position(gui.get_node("xp_fg"), self.xp_fg_position_current)

	gui.set_text(gui.get_node("level"), self.level)
	gui.set_text(gui.get_node("current_xp"), math.min(self.current_xp, self.max_xp))
end

function on_message(self, message_id, message, sender)
	-- Add message-handling code here
	-- Remove this function if not needed
end

function on_input(self, action_id, action)
	if action_id == hash("key_z") and action.released or action_id == hash("click") and action.released then
		update_xp(self)
	end
end

function on_reload(self)
	-- Add input-handling code here
	-- Remove this function if not needed
end
